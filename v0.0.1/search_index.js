var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = SpatialMultitaper","category":"page"},{"location":"#SpatialMultitaper","page":"Home","title":"SpatialMultitaper","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SpatialMultitaper.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [SpatialMultitaper]","category":"page"},{"location":"#SpatialMultitaper.L2_inner_product_interpolated-Union{Tuple{D}, Tuple{T}, Tuple{AbstractArray{T, D}, AbstractArray{T, D}, CartesianGrid{M, C, N} where {M<:Meshes.ð”¼, C<:CoordRefSystems.Cartesian, N}}} where {T, D}","page":"Home","title":"SpatialMultitaper.L2_inner_product_interpolated","text":"interp_ip_2(h::AbstractArray{T,D}, g::AbstractArray{T,D}, grid::CartesianGrid) where {T,D}\n\nThe Lâ‚‚ inner product of interpolated sequences g and h recorded on grid grid.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.box2sides-Tuple{Meshes.Box}","page":"Home","title":"SpatialMultitaper.box2sides","text":"box2sides(box::Box)\n\nConverts a box to a tuple of tuples, whose j'th entry is thej`th coordinate of the minimum and maximum of the box.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.choose_freq_1d-Tuple{Any, Any}","page":"Home","title":"SpatialMultitaper.choose_freq_1d","text":"choose_freq_1d(nfreq, fmax)\n\nReturns the frequencies for our fft interfaces, with nfreq frequencies, and fmax as the fmax frequency.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.choose_freq_res-Tuple{Any, Any}","page":"Home","title":"SpatialMultitaper.choose_freq_res","text":"choose_freq_res(n, nfreq; maxitr=100)\n\nFind the smallest integer oversample such that nfreq*oversample â‰¥ n.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.downsample-Union{Tuple{T}, Tuple{D}, Tuple{AbstractArray{T, D}, Int64}} where {D, T}","page":"Home","title":"SpatialMultitaper.downsample","text":"downsample(x::AbstractArray{T,D}, spacing) where {D,T}\n\nDown sample an AbstractArray. Specify spacing as an Int, for same spacing in all dims. Specify spacing as an NTuple{D,Int} for different spacing. Specify spacing=nothing to just return x.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.fft_anydomain-Union{Tuple{D}, Tuple{Array, Meshes.Grid, Tuple{Vararg{Int64, D}}, Tuple{Vararg{Number, D}}}} where D","page":"Home","title":"SpatialMultitaper.fft_anydomain","text":"fft_anydomain(x::Array, grid::Grid, nfreq, fmax; kwargs...)\n\nApply an fft to data stored in x given that x is recorded on a grid grid. The output is at frequencies determined by nfreq and fmax. x can have more dimensions than grid but the first dimensions must be the same as the grid (up to the size of the grid).\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.freq_downsample_index-Tuple{Any, Any}","page":"Home","title":"SpatialMultitaper.freq_downsample_index","text":"freq_downsample_index(nfreq, oversample)\n\nReturns the indices required to downsample the oversampled frequencies with a given oversampling. This assumes that the frequencies are fftshifted.\n\nArguments\n\nnfreq::Int: The number of frequencies for the desired output.\noversample::Int: The oversampling factor used.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.freq_downsample_startindex-Tuple{Any, Any}","page":"Home","title":"SpatialMultitaper.freq_downsample_startindex","text":"freq_downsample_startindex(nfreq,oversample)\n\nReturns the starting index for the oversampled frequencies to downsample.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.grid2side-Tuple{CartesianGrid{M, C, N} where {M<:Meshes.ð”¼, C<:CoordRefSystems.Cartesian, N}}","page":"Home","title":"SpatialMultitaper.grid2side","text":"grid2side(g::CartesianGrid)\n\nConverts a grid to a tuple of the location of the centers for each side.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.interpolated_taper_family-Tuple{Vector{<:AbstractArray}, CartesianGrid{M, C, N} where {M<:Meshes.ð”¼, C<:CoordRefSystems.Cartesian, N}}","page":"Home","title":"SpatialMultitaper.interpolated_taper_family","text":"interpolated_taper_family(raw_tapers, grid; freq_res=size(grid))\n\nConstructs a multitaper object from multiple taper discrete impulse responses on a grid. \n\nArguments\n\nraw_tapers: A Vector of AbstractArrays containing the taper impulse response.\ngrid: The grid corresponding to the tapers.\nfreq_res: Optional named arguemnt specifying the upsampling for computing the transfer function.\n\nFrequency sampling\n\nThe frequency grid on which the transfer function will be sampled has:\nlength freq_res.\ninterval unitless_spacing(grid)/freq_res.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.multitaper_estimate-Tuple{Union{GeoTables.GeoTable, PointSet}, Any}","page":"Home","title":"SpatialMultitaper.multitaper_estimate","text":"multitaper_estimate(data, tapers; nfreq, fmax, region, jackknife=false, mean_method = DefaultMean())\n\nComputes the multitaper spectral estimate from a tapered dft.\n\nArguments:\n\ndata: The data to estimate the spectrum from.\ntapers: A tuple of taper functions.\nnfreq::NTuple{D,Int}: The number of frequencies in each dimension.\nfmax::NTuple{D,Real}: The maximum frequency in each dimension.\nregion: The region to estimate the spectrum from.\njackknife: If true, jackknife (leave one out) replicates returned.\nmean_method: The method to estimate the mean. Default is DefaultMean, but can use KnownMean(x) to specify this if known.\n\nOutput:\n\nIf the data has P processes, and nfreq = (n1,...,nD), the output is a named tuple with\n\nfreq: a tuple of array of frequencies in each dimension (note this is ordered in increasing frequency).\npower: the P x P x n1 x ... x nD array.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.newweight-Tuple{AbstractArray, Nothing}","page":"Home","title":"SpatialMultitaper.newweight","text":"newweight(h, freq_downsampling)\n\nNecessary because eigs gives normalised vector under the downsampling.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.nufft1d1_anydomain!-NTuple{6, Any}","page":"Home","title":"SpatialMultitaper.nufft1d1_anydomain!","text":"nufft1d1_anydomain!(output_storage, input_data, nfreq, fmax, iflag, eps; kwargs...)\n\nIn place version of nufft1d1_anydomain. Use nufft1d1_anydomain_precomp to precompute the input data and memory required.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.nufft1d1_anydomain-NTuple{7, Any}","page":"Home","title":"SpatialMultitaper.nufft1d1_anydomain","text":"nufft1d1_anydomain(interval, nfreq, fmax, xj, cj, iflag, eps; kwargs...)\n\nComputes the approximate dft of a 1d function using the nufft algorithm, with points in any interval, at frequencies defined by fmax and nfreq. xj are the points coordinates and cj are the function values. Set iflag<0 for -i in exponent.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.nufft1d1_anydomain_precomp-NTuple{5, Any}","page":"Home","title":"SpatialMultitaper.nufft1d1_anydomain_precomp","text":"nufft1d1_anydomain_precomp(interval, nfreq, fmax, xj, cj)\n\nPrecomputes the input data and memory required for nufft1d1_anydomain!.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.nufft2d1_anydomain!-NTuple{6, Any}","page":"Home","title":"SpatialMultitaper.nufft2d1_anydomain!","text":"nufft2d1_anydomain!(output_storage, input_data, nfreq, fmax, iflag, eps; kwargs...)\n\nIn place version of nufft2d1_anydomain. Use nufft2d1_anydomain_precomp to precompute the input data and memory required.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.nufft2d1_anydomain-NTuple{8, Any}","page":"Home","title":"SpatialMultitaper.nufft2d1_anydomain","text":"nufft2d1_anydomain(box, nfreq, fmax, xj, yj, cj, iflag, eps; kwargs...)\n\nComputes the approximate dft of a 2d function using the nufft algorithm, with points in any box, at frequencies defined by fmax and nfreq. box here should be a tuple of intervals, one for each dimension. Similarly for fmax and nfreq. xj, yj are the points coordinates and cj are the function values. Set iflag<0 for -i in exponent.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.nufft2d1_anydomain_precomp-NTuple{6, Any}","page":"Home","title":"SpatialMultitaper.nufft2d1_anydomain_precomp","text":"nufft2d1_anydomain_precomp(box, nfreq, fmax, xj, yj, cj)\n\nPrecomputes the input data and memory required for nufft2d1_anydomain!.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.nufft3d1_anydomain!-NTuple{6, Any}","page":"Home","title":"SpatialMultitaper.nufft3d1_anydomain!","text":"nufft3d1_anydomain!(output_storage, input_data, nfreq, fmax, iflag, eps; kwargs...)\n\nIn place version of nufft3d1_anydomain. Use nufft3d1_anydomain_precomp to precompute the input data and memory required.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.nufft3d1_anydomain-NTuple{9, Any}","page":"Home","title":"SpatialMultitaper.nufft3d1_anydomain","text":"nufft3d1_anydomain(cube, nfreq, fmax, xj, yj, zj, cj, iflag, eps; kwargs...)\n\nComputes the approximate dft of a 3d function using the nufft algorithm, with points in any cube, at frequencies defined by fmax and nfreq. cube here should be a tuple of intervals, one for each dimension. Similarly for fmax and nfreq. xj, yj, zj are the points coordinates and cj are the function values. Set iflag<0 for -i in exponent.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.nufft3d1_anydomain_precomp-NTuple{7, Any}","page":"Home","title":"SpatialMultitaper.nufft3d1_anydomain_precomp","text":"nufft3d1_anydomain_precomp(cube, nfreq, fmax, xj, yj, zj, cj)\n\nPrecomputes the input data and memory required for nufft3d1_anydomain!.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.nufft_anydomain-Tuple{Any, Any, Any, PointSet, Any, Any, Any}","page":"Home","title":"SpatialMultitaper.nufft_anydomain","text":"nufft_anydomain(region, nfreq, fmax, points::PointSet, c, iflag, eps; kwargs...)\n\nComputes the approximate dft of a function using the nufft algorithm, with points in any region, at frequencies defined by fmax and nfreq. Currently only 1d, 2d and 3d are supported.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.optimaltapers-Tuple{Union{Meshes.Domain, Meshes.Geometry}, CartesianGrid{M, C, N} where {M<:Meshes.ð”¼, C<:CoordRefSystems.Cartesian, N}}","page":"Home","title":"SpatialMultitaper.optimaltapers","text":"optimaltapers(region::Meshes.GeometryOrDomain, grid::CartesianGrid; freq_region::Meshes.GeometryOrDomain, ntapers::Int, freq_res, freq_downsample=nothing, real_tapers=true, tol=0.0)\n\nFunction to compute the optimal tapers for a given region, grid and region in frequency.\n\nArguments:\n\nregion: The spatial observation region. Should be of type Geometry or Domain.\ngrid: A CartesianGrid containing the region on which we wish to have a taper.\nfreq_region: The region in frequency we want to concentrate the taper on. Typically a Ball centered at zero.\nntapers: The number of desired tapers.\nfreq_res: The oversampling to be used in frequency.\nreal_tapers: Optional argument to decided if real or complex tapers should be provided. Default is true which provides real tapers.\ntol: Optional argument passed to the eigs function of Arpack. You likely need to play with this.\n\nNote about errors:\n\nIf you have an error, it is likely a convergence problem. Try setting a larger value for tol.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.pad-Union{Tuple{D}, Tuple{T}, Tuple{AbstractArray{T, D}, Int64}} where {T, D}","page":"Home","title":"SpatialMultitaper.pad","text":"pad(x::AbstractArray{T,D}, n::NTuple{D,Int}) where {T,D}\npad(x::AbstractArray{T,D}, n::Int) where {T,D}\n\nPad x with zeros to size n.  Note that size(x) â‰¤ n must hold, and the new array is of size n not size(x).+n. If an integer is provided for n, it is interpreted as ntuple(d->n, Val{D}()).\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.points2coords-Tuple{PointSet}","page":"Home","title":"SpatialMultitaper.points2coords","text":"points2coords(points::PointSet)\n\nConverts PointSet to a tuple of arrays, whose j'th entry is thej`th coordinate of each of the points.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.reprocess-Union{Tuple{T}, Tuple{D}, Tuple{AbstractArray{T, D}, Any, Any}} where {D, T}","page":"Home","title":"SpatialMultitaper.reprocess","text":"reprocess(h_large, grid, freq_downsample)\n\nUndoes the downsampling and padding.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.rescale_points-NTuple{4, Any}","page":"Home","title":"SpatialMultitaper.rescale_points","text":"rescale_points(x, nfreq, fmax, interval; max_oversample = 100)\n\nRescales points to be in the interval [-Ï€, Ï€] and returns the oversampling factor. Oversampling factor is the smallest integer such that the interval is rescaled to fit in [-Ï€, Ï€], and the corresponding fmax frequency is a multiple of fmax. Interval just needs to have minimum and maximum defined.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.side2grid-Tuple{Tuple{Vararg{T, N}} where {N, T}}","page":"Home","title":"SpatialMultitaper.side2grid","text":"side2grid(sides)\n\ninverse of grid2side\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.sin_taper_family-Tuple{Any, Meshes.Box}","page":"Home","title":"SpatialMultitaper.sin_taper_family","text":"make_sin_tapers(lbw, region::Box, gridsize)\n\nConstruct the sin tapers for a given region and gridsize.\n\nArguments:\n\nntapers: The number of tapers.\nregion: The region to construct the tapers on. Must be a box.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.tapered_dft-Union{Tuple{P}, Tuple{Tuple{Vararg{Union{GeoTables.GeoTable, PointSet}, P}}, Any, Any, Any, Any, Tuple{Vararg{SpatialMultitaper.MeanEstimationMethod, P}}}} where P","page":"Home","title":"SpatialMultitaper.tapered_dft","text":"tapered_dft(data::NTuple{P,Union{GeoTable, PointSet}}, tapers, nfreq, fmax, region, mean_method::NTuple{P,MeanEstimationMethod}) where {P}\n\nCompute the tapered discrete Fourier transform of a collection of data sets. If we have n1,...,nD frequencies, and M tapers and P processes, this returns an array of size M x P x n1 x ... x nD.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.unwrap_fft_output-Union{Tuple{D}, Tuple{AbstractArray, Tuple{Vararg{Int64, D}}}} where D","page":"Home","title":"SpatialMultitaper.unwrap_fft_output","text":"unwrap_fft_output(J::AbstractArray, fmaxrel::NTuple{D, Int}) where {D}\n\nCopies the result of the fft to give something which goes up to some multiple of the nyquist frequency (whilst keeping the number of output frequencies).\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.unwrap_index-Tuple{Any, Any}","page":"Home","title":"SpatialMultitaper.unwrap_index","text":"unwrap_index(n, a)\n\nThe indices required to unwrap the fft output to go up to n with a given oversampling a.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialMultitaper.upsample-Tuple{AbstractArray, CartesianGrid{M, C, N} where {M<:Meshes.ð”¼, C<:CoordRefSystems.Cartesian, N}, Nothing}","page":"Home","title":"SpatialMultitaper.upsample","text":"upsample(x::AbstractArray, grid::CartesianGrid, freq_downsample)\n\nUpsamples an array using linear interpolation, checking the grid size against x. Note this is specific to downsample as used here, and shouldn't be used for general upsampling.\n\n\n\n\n\n","category":"method"}]
}
